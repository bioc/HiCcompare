---
title: "smyth_comparison"
author: "John Stansfield"
date: "December 13, 2017"
output: html_document
---

```{r}
library(HiCcompare)
library(data.table)
library(InteractionSet)
library(MDmisc)
library(ggplot2)
library(gridExtra)
```

```{r}
options(stringsAsFactors = FALSE)
```

```{r}
dataframe2interactionset <- function(df) {
  df <- as.data.frame(df)
  set1 <- GRanges(df$chr1, IRanges(start = df$start1, end = df$end1))
  set2 <- GRanges(df$chr2, IRanges(start = df$start2, end = df$end2))
  gi <- GInteractions(set1, set2)
  if (ncol(df) > 6) {
    S4Vectors::values(gi) <- cbind(S4Vectors::values(gi), df[, 7:ncol(df)])
  }
  return(gi)
}
```


# Redone data
## read in lib1 data
```{r}
# core_path <- "C:/VM_Shared/DNA_int_analysis/rickman/rickman_lib1/"
# man_path <- "C:/VM_Shared/DNA_int_analysis/manuscript/prostate_analysis/"

core_path <- "D:/3D_DNA/rickman/rickman_lib1/"
man_path <- "D:/3D_DNA/manuscript/prostate_analysis/"

chrs <- paste0('chr', 1:22)
chrs <- c(chrs, 'chrX')

# read in data for 1 mb
ERG_lib1 <- list()
GFP_lib1 <- list()
for(i in 1:22) {
  ERG_lib1[[i]] <- read.table(paste0(core_path, 'ERG_lib1_chr', i, '.1mb.txt'), header = FALSE)
  GFP_lib1[[i]] <- read.table(paste0(core_path, 'GFP_lib1_chr', i, '.1mb.txt'), header = FALSE)
}
ERG_lib1[[23]] <- read.table(paste0(core_path, 'ERG_lib1_chr', 'X', '.1mb.txt'), header = FALSE)
GFP_lib1[[23]] <- read.table(paste0(core_path, 'GFP_lib1_chr', 'X', '.1mb.txt'), header = FALSE)

```


## Read in smyth data

```{r}
# set up their data for overlap analysis
# core_path <- "C:/VM_Shared/DNA_int_analysis/prostate_data/"
core_path <- "D:/3D_DNA/prostate_data/"
library(readr)
their.results <- read_tsv(paste0(core_path, 'results.tsv'))
# their.results <- subset(their.results, FDR < 0.05)
# they used the lower triangle of the matrix for most pairs of regions while we only use upper triangle. need to convert to upper triangle for overlap to work
new_start1 <- ifelse(their.results$anchor.start >= their.results$target.start, their.results$target.start, their.results$anchor.start)
new_end1 <- ifelse(their.results$anchor.end >= their.results$target.end, their.results$target.end, their.results$anchor.end)
new_start2 <- ifelse(their.results$anchor.start >= their.results$target.start, their.results$anchor.start, their.results$target.start)
new_end2 <- ifelse(their.results$anchor.end >= their.results$target.end, their.results$anchor.end, their.results$target.end)
new.their.results <- data.frame(anchor = their.results$anchor, anchor.start = new_start1, anchor.end = new_end1, 
                                target = their.results$target, target.start = new_start2, target.end = new_end2)
new.their.results <- cbind(new.their.results, their.results[, 7:11])
their.results <- new.their.results
s1 <- GRanges(their.results$anchor, IRanges(start = their.results$anchor.start, end = their.results$anchor.end))
s2 <- GRanges(their.results$target, IRanges(start = their.results$target.start, end = their.results$target.end))
smyth.gi <- GInteractions(s1, s2)
meta <- cbind(their.results$logFC, their.results$logCPM, their.results$F, their.results$PValue, their.results$FDR)
meta <- as.data.frame(meta)
colnames(meta) <- c('logFC', 'logCPM', 'F', 'PValue', 'FDR')
S4Vectors::values(smyth.gi) <- cbind(S4Vectors::values(smyth.gi), meta)
```


```{r}
# try to get smyth data into same regions as our data
their.results <- as.data.table(their.results)
their.results <- their.results[, 1:11, with = FALSE]
# sort
their.results <- their.results[order(anchor, target, anchor.start, target.start)]

tmp <- their.results[1:100,]
tmp$anchor.start - tmp$anchor.end

# function to convert their ranges to ours
convert_ranges <- function(tb, res = 1000000) {
  # divide by 1,000,000 then round to nearest integer then multiply back by 1,000,000
  new.start <- (tb$anchor.start / res) %>% round(., digits = 0) * res
  new.end <- (tb$anchor.end / res) %>% round(., digits = 0) * res
  tb[, start1 := new.start]
  tb[, end1 := new.end]
  new.start <- (tb$target.start / res) %>% round(., digits = 0) * res
  new.end <- (tb$target.end / res) %>% round(., digits = 0) * res
  tb[, start2 := new.start]
  tb[, end2 := new.end]
  diff1 <- tb$end1 - tb$start1
  diff2 <- tb$end2 - tb$start2
  idx <- which(tb$start1 == tb$end1)
  # idx <- which(diff1 < res)
  for(i in 1:length(idx)) {
    tb[idx[i], start1 := (anchor.start / res) %>% floor() * res]
    tb[idx[i], end1 := (anchor.end / res) %>% ceiling() * res]
  }
  idx <- which(tb$start2 == tb$end2)
  # idx <- which(diff2 < res)
  for(i in 1:length(idx)) {
    tb[idx[i], start2 := (target.start / res) %>% floor() * res]
    tb[idx[i], end2 := (target.end / res) %>% ceiling() * res]
  }
  tb[start1 == end1, end1 := end1 + res]
  tb[start2 == end2, end1 := end1 + res]
  
  return(tb)
}



# function to convert their ranges to ours
convert_ranges <- function(tb, res = 1000000) {
  # divide by 1,000,000 then round to nearest integer then multiply back by 1,000,000
  new.start <- (tb$anchor.start / res) %>% floor() * res
  new.end <- (tb$anchor.end / res) %>% ceiling() * res
  tb[, start1 := new.start]
  tb[, end1 := new.end]
  new.start <- (tb$target.start / res) %>% round(., digits = 0) * res
  new.end <- (tb$target.end / res) %>% round(., digits = 0) * res
  tb[, start2 := new.start]
  tb[, end2 := new.end]
  diff1 <- tb$end1 - tb$start1
  diff2 <- tb$end2 - tb$start2
  idx <- which(tb$start1 == tb$end1)


  tb[start1 == end1,]
  tb[start2 == end2, end1 := end1 + res]
  
  return(tb)
}

# some of the regions are ending up with 0 range of greater than 1 mil range
their.results <- convert_ranges(their.results)
their.results[, diff2 := target.end - target.start]
their.results[, diff1 := anchor.end - anchor.start]
```


# read in our data
```{r}
lib1_tables <- mapply(create.hic.table, ERG_lib1, GFP_lib1, chrs, SIMPLIFY = FALSE, MoreArgs = list(scale = FALSE))
```

# try to overlap with all regions
```{r}
# get all regions
all_reg <- lapply(ERG_lib1, sparse2full)
all_cols <- lapply(all_reg, colnames)
regions <- mapply(function(x, y) {
  x <- as.numeric(x)
  reg <- data.table(chr = y, start = x, end = x + 1000000)
  return(reg)
}, all_cols, paste0('chr', c(1:22, 'X')), SIMPLIFY = FALSE)

regions <- rbindlist(regions)
r.gr <- GRanges(regions$chr, ranges = IRanges(start=regions$start, end = regions$end))
colnames(their.results)[1:6] <- c('chr1', 'start1', 'end1', 'chr2', 'start2', 'end2')
smyth.gi <- dataframe2interactionset(as.data.frame(their.results))

olaps <- findOverlaps(smyth.gi, r.gr, use.region = 'first')

smyth.gi[olaps@from[1:10],]
r.gr[olaps@to[1:10],]
```



